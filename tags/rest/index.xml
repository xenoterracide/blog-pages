<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rest on Caleb Cushing&#39;s blog</title>
    <link>http://blog.xenoterracide.com/tags/rest/index.xml</link>
    <description>Recent content in Rest on Caleb Cushing&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.xenoterracide.com/tags/rest/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>REST, ROA, and HATEOAS often leads to bad webservice design</title>
      <link>http://blog.xenoterracide.com/post/rest-roa-and-hateoas-often-leads-to-bad-webservice-design/</link>
      <pubDate>Wed, 02 Apr 2014 04:00:00 +0000</pubDate>
      
      <guid>http://blog.xenoterracide.com/post/rest-roa-and-hateoas-often-leads-to-bad-webservice-design/</guid>
      <description>&lt;p&gt;&lt;p&gt;This is not to say that they are bad, but I find that all too frequently the resulting API&amp;rsquo;s are poorly designed due to forgetting one thing, RPC (Remote Procedure Call) is expensive. Now by RPC, I do not mean custom messaging formats such as SOAP, or XML-RPC, I mean calling a method on a remote server. Do not think that just because you are using HTTP as the message format with something like XML or JSON, that calling &lt;code&gt;GET /resource&lt;/code&gt;, is significantly all that different from calling get_resource in a SOAP call. The frequent idempotence also does not mean that you&amp;rsquo;re not actually doing RPC as often good method design server side also implies idempotence, e.g. adding an object to a Set in Java will not result in the object being added twice if you add it twice. All calls to a remote is a form of RPC. The most expensive part of RPC is creating a new connection, just how depends on the protocol. This is why web sockets, for instance, is much cheaper than repeated calls (there are other reasons and expenses too, like maintaining many connections). &lt;/p&gt;&lt;p&gt;I&amp;rsquo;ve worked with a few Resource Oriented Architecture (ROA) web services, and they each suffered from the same flawed design, an excessive number of RPC calls was required to do seemingly simple tasks. This is caused by the, misguided, belief that every single aggregate should be it&amp;rsquo;s own resource and that components of the aggregate should also have it&amp;rsquo;s own resource, and that those should be the only access to the underlying aggregate. In one case working with an ROA we had to do about 5 RPC calls for every single product we wanted to create, and we were bulk creating. This problem was aggravated by the lack of an idempotent PUT for most resources. &lt;/p&gt;&lt;p&gt;The reality is, with a good API design we could have created all, of the objects we needed with a single API call to a bulk interface. I&amp;rsquo;m talking the RESTful equivalent to a &lt;a href=&#34;http://download.java.net/jdk8/docs/api/java/util/Collection.html#addAll-java.util.Collection-&#34;&gt;Java &lt;code&gt;Collection.addAll( objs[] )&lt;/code&gt;&lt;/a&gt;. In fact if you use addAll on a Set, the result of multiple same calls is idempotent, the same object will not be added twice. It would be really easy to write this given a good ORM, and a good interface so that you could do a &lt;code&gt;POST&lt;/code&gt; or &lt;code&gt;PUT&lt;/code&gt; to &lt;code&gt;/entities&lt;/code&gt;.  this is a significant improvement to a design where you&amp;rsquo;d have to do a PUT or POST for every single item you wanted to create. &lt;code&gt;DELETE&lt;/code&gt; may be the only place where I&amp;rsquo;d consider not doing a bulk request, and it is generally able to be completed asynchronously. You may of course consider limiting the number of entities acted on in a request, so if you need to create 1000 entities, it might take 10 requests doing 100 at a time, this is still better for both the client and the server than doing 1000 requests. &lt;/p&gt;&lt;p&gt;The choice between &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; depends on whether you believe that the call to &lt;code&gt;GET&lt;/code&gt; must return the exact same view as &lt;code&gt;PUT&lt;/code&gt;, meaning that a &lt;code&gt;PUT&lt;/code&gt; would delete resources not included (for a single aggregate that&amp;rsquo;s probably true), or should the behavior be equivalent to addAll or replacing the reference to the collection with a new one. Remember &lt;code&gt;PUT&lt;/code&gt; must be idempotent, this &lt;em&gt;only&lt;/em&gt; means that subsequent calls using the exact same arguments should result in the exact same result. You may want to consider using a different URI for manipulating your entity collections in these ways. &lt;/p&gt;&lt;p&gt;Another problem that was encountered with a web service we encountered is it had sub resources, that had to exist prior to creating the resource we needed to create, akin to tags. Not having a idempotent put to that resource meant we were doing create on exception update. But given the simplicity of this resource it would have been even better to just allow the api to take the final object representation of that resource, instead of requiring the id, and done a lookup by name, or a create or update, under the hood. Doing this is more difficult logic wise, and impossible if there&amp;rsquo;s no natural key (because you can&amp;rsquo;t look it up). &lt;/p&gt;&lt;p&gt;You probably are asking yourself, but how do I handle errors for these things. Well, the way I see it you have three options. One requests are a transaction, so you wrap your database code with a transaction, and it either succeeds or fails, you can return a 200 on success, ensure HATEOAS, with links to any new resources in the response. Two, you could allow partial success, and return the successful objects. Three you could return a custom message envelope payload, this isn&amp;rsquo;t very RESTful because it&amp;rsquo;s a protocol on top of HTTP (it&amp;rsquo;s more like SOAP). &lt;p&gt;I&amp;rsquo;m currently working on designing a new REST Web Service, and I&amp;rsquo;ve decided that no page load, or &amp;ldquo;single conceptual action&amp;rdquo; should take more than 6 API requests. This number is not arbitrary, it&amp;rsquo;s the &lt;a href=&#34;http://www.browserscope.org/?category=network&#34;&gt;median concurrent connection amount, per host name, for consumer web browsers&lt;/a&gt;. Even that number is too many, but I felt that I needed to alot more than one request allowed due to some completely different actions that may need to occur on a page load. &lt;/p&gt;&lt;p&gt;Keep on with the Resource Oriented REST with HATEOAS, just try to think of how to minify the number of calls you make by designing less granular resources&lt;/p&gt;&lt;div class=&#34;blogger-post-footer&#34;&gt;&lt;br /&gt;&amp;ndash;&lt;br /&gt;
This &lt;span xmlns:dc=&#34;http://purl.org/dc/elements/1.1/&#34; href=&#34;http://purl.org/dc/dcmitype/Text&#34; rel=&#34;dc:type&#34;&gt;work&lt;/span&gt; by &lt;a xmlns:cc=&#34;http://creativecommons.org/ns#&#34; href=&#34;http://www.xenoterracide.com&#34; property=&#34;cc:attributionName&#34; rel=&#34;cc:attributionURL&#34;&gt;Caleb Cushing&lt;/a&gt; is licensed under a &lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/3.0/&#34;&gt;Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>