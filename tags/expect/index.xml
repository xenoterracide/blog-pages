<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Expect on Caleb Cushing&#39;s blog</title>
    <link>http://blog.xenoterracide.com/tags/expect/index.xml</link>
    <description>Recent content in Expect on Caleb Cushing&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.xenoterracide.com/tags/expect/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Simple scripting CLI with Expect.pm</title>
      <link>http://blog.xenoterracide.com/post/simple-scripting-cli-with-expect.pm/</link>
      <pubDate>Sun, 04 Mar 2012 02:04:00 +0000</pubDate>
      
      <guid>http://blog.xenoterracide.com/post/simple-scripting-cli-with-expect.pm/</guid>
      <description>&lt;p&gt;&lt;p&gt;Expect is use primarily for sending Input to Command Line programs that Prompt and wait for input. For starters you&amp;rsquo;ll need an executable script and I&amp;rsquo;ve pasted one that I got elsewhere for a demo. &lt;script src=&#34;https://gist.github.com/1970845.js?file=agencolor.pl&#34;&gt;&lt;/script&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env perl&lt;br /&gt;# slightly modified from &lt;a href=&#34;http://www.tizag.com/perlT/perluserinput.php&#34;&gt;http://www.tizag.com/perlT/perluserinput.php&lt;/a&gt;&lt;br /&gt;use 5.014;;&lt;br /&gt;use warnings;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;print &amp;ldquo;How old are you?&amp;rdquo;;&lt;br /&gt;my $age = &amp;lt;&amp;gt;;&lt;br /&gt;&lt;br /&gt;print &amp;ldquo;What is your favorite color?&amp;rdquo;;&lt;br /&gt;my $color = &amp;lt;&amp;gt;;&lt;br /&gt;&lt;br /&gt;say &amp;ldquo;You are $age, and your favorite color is $color.&amp;rdquo;;&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt; It&amp;rsquo;s trivial, you should probably run it just to see what it does. Now take a look at our Expect Script.&lt;/p&gt; &lt;script src=&#34;https://gist.github.com/1970845.js?file=expect.pl&#34;&gt;&lt;/script&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;#!/usr/bin/env perl&lt;br /&gt;use 5.014;&lt;br /&gt;use warnings;&lt;br /&gt;&lt;br /&gt;use Expect;&lt;br /&gt;use List::AllUtils qw( natatime );&lt;br /&gt;&lt;br /&gt;my @cmd = ( &amp;lsquo;./agencolor.pl&amp;rsquo; ); # spawn takes command plus argumements&lt;br /&gt;my @params = ( &amp;lsquo;34&amp;rsquo;, &amp;lsquo;hot pink&amp;rsquo; );&lt;br /&gt;my @oparams = ( qw( 43 blue ) );&lt;br /&gt;&lt;br /&gt;my $param  = natatime 1, @params; # iterator&lt;br /&gt;my $oparam = natatime 1, @params; # iterator&lt;br /&gt;&lt;br /&gt;my $exp = Expect-&amp;gt;new;&lt;br /&gt;$exp-&amp;gt;exp_internal( 1 ); # print better debug than -&amp;gt;debug( 3 )&lt;br /&gt;$exp-&amp;gt;spawn( @cmd );&lt;br /&gt;&lt;br /&gt;$exp-&amp;gt;expect(&lt;br /&gt; 1, # timeout in seconds&lt;br /&gt;&lt;br /&gt; # both regex&amp;rsquo;s will try to match for every line&lt;br /&gt; [ qr/\?$/, sub { $exp-&amp;gt;send( $param-&amp;gt;() . &amp;ldquo;\n&amp;rdquo; ); exp_continue; }, ],&lt;br /&gt; [ qr/:$/, sub { $exp-&amp;gt;send( $oparam-&amp;gt;() . &amp;ldquo;\n&amp;rdquo; ); exp_continue; }, ],&lt;br /&gt; # the above line will never match&lt;br /&gt;);&lt;br /&gt;&lt;br /&gt;say &amp;lsquo;-&amp;lsquo;x 10;&lt;br /&gt;say $exp-&amp;gt;before;&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt; &lt;p&gt;Although you can read the comments yourself, let&amp;rsquo;s go over it anyways. &lt;code&gt;-&amp;gt;spawn&lt;/code&gt; takes a list of arguments, with the first being a command, and the rest being any command line arguments, or options passed to said script. I could have easily just put the command in spawn, but I though I&amp;rsquo;d show a more dynamic example. After that you&amp;rsquo;ll notice I&amp;rsquo;ve hard coded 2 sets of params that could possibly be fed into the program. I also have created some 1 at a time iterators, this simply makes it easier to iterate them in expect. Now onto the Expect object itself.&lt;/p&gt; &lt;p&gt;If you&amp;rsquo;ve read the documentation you&amp;rsquo;ll notice there are 3 debug settings, with 3 being the most verbose, and some verbose settings. None of this appeared to be as verbose as I could get, however turning on &lt;code&gt;-&amp;gt;exp_internal(1);&lt;/code&gt; printed everything I needed to understand expect and debug what I was doing wrong. The &lt;code&gt;-&amp;gt;spawn&lt;/code&gt; method of course forks and execs our command, the output of which then gets iterated by &lt;code&gt;-&amp;gt;expect&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;The first argument to &lt;code&gt;-&amp;gt;expect&lt;/code&gt; is the timeout, which is measured in seconds. The timeout is how long expect will wait for the output to match one of the regexes. You could set it to &lt;code&gt;undef&lt;/code&gt; if you want to wait forever, or if it&amp;rsquo;s just a program that has some startup time before it prompts set it to a few seconds. The timeout will (by default) be used again in between each prompt.&lt;/p&gt; &lt;p&gt;After timeout you can specify a list of array refs, each of which has 2 elements. The first is a regular expression that will allow you to tell expect how to recognize a prompt. The second is a coderef which allows you to tell expect what to do if it&amp;rsquo;s corresponding match is hit. Both regexes will be run against every line, checking to see if they match.&lt;/p&gt; &lt;p&gt;Inside of our coderef we can use &lt;code&gt;-&amp;gt;send&lt;/code&gt; to send input to the prompt. Remember &lt;code&gt;send&lt;/code&gt; doesn&amp;rsquo;t automatically press enter, so be sure to add your newlines. &lt;code&gt;exp_continue&lt;/code&gt; means after match continue using this &lt;code&gt;-&amp;gt;expect&lt;/code&gt; call to try to match the next line.&lt;/p&gt; &lt;p&gt;When running the script you&amp;rsquo;ll notice the second regex never matches, but if reading the &amp;lsquo;internal&amp;rsquo; output you&amp;rsquo;ll see that it is attempting to.&lt;/p&gt; &lt;p&gt;The last line is a call to &lt;code&gt;-&amp;gt;before&lt;/code&gt; which in this case, not very intuitively prints everything that was in the pty after the last match, or more appropriately, before the program exited. You&amp;rsquo;ll also notice that it collects the thing that you sent to the last match.&lt;/p&gt; &lt;p&gt;That&amp;rsquo;s the basics of what I&amp;rsquo;ve discovered, I&amp;rsquo;m not sure I fully understand how it all works yet (which means my explanations might not be 100% correct), but perhaps me writing this will help someone else get started with Expect. Happy Hacking! &lt;/p&gt;&lt;div class=&#34;blogger-post-footer&#34;&gt;&lt;br /&gt;&amp;ndash;&lt;br /&gt;
This &lt;span xmlns:dc=&#34;http://purl.org/dc/elements/1.1/&#34; href=&#34;http://purl.org/dc/dcmitype/Text&#34; rel=&#34;dc:type&#34;&gt;work&lt;/span&gt; by &lt;a xmlns:cc=&#34;http://creativecommons.org/ns#&#34; href=&#34;http://www.xenoterracide.com&#34; property=&#34;cc:attributionName&#34; rel=&#34;cc:attributionURL&#34;&gt;Caleb Cushing&lt;/a&gt; is licensed under a &lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/3.0/&#34;&gt;Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>