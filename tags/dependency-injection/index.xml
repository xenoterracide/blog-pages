<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dependency Injection on Caleb Cushing&#39;s blog</title>
    <link>http://blog.xenoterracide.com/tags/dependency-injection/index.xml</link>
    <description>Recent content in Dependency Injection on Caleb Cushing&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.xenoterracide.com/tags/dependency-injection/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Providing with Providers and Bread::Board</title>
      <link>http://blog.xenoterracide.com/post/providing-with-providers-and-breadboard/</link>
      <pubDate>Wed, 23 Oct 2013 05:56:00 +0000</pubDate>
      
      <guid>http://blog.xenoterracide.com/post/providing-with-providers-and-breadboard/</guid>
      <description>&lt;p&gt;&lt;p&gt;So when I started using Dependency Injection the following problem happened, how do I Inject this dependency when the container is not accessible at this point. Ok, that sentence even confused me a little bit, so what do I mean. Let&amp;rsquo;s say I have a &lt;a href=&#34;http://www.martinfowler.com/eaaCatalog/repository.html&#34;&gt;Repository&lt;/a&gt; for Products that is injected into my controller. Each Product stored has one or more ProductVariants that is part of it&amp;rsquo;s aggregate, which itself has Nested Categories. Loading this entire graph at once would be relatively expensive, so we decide to do some lazy loading via DBI in the classes. One problem, how on earth do we Inject a Database Handle all the way down to Categories. Most of these ways are against DI, but they are solutions to the problem, there are also ways to combine these. Also, your model class having a database handle is probably bad design itself, but I&amp;rsquo;m not going to get into that. Sadly I&amp;rsquo;ve done every one of these &lt;/p&gt;&lt;h2&gt;Manual&lt;/h2&gt;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/xenoterracide/7047751.js&#34;&gt;&lt;/script&gt;Well at least you aren&amp;rsquo;t hard coding the way to read your config file, or your database driver. You&amp;rsquo;re smart enough to rely on an Interface rather than an Implementation. This is fraught with so many problems. Firstly if your web server (assuming it&amp;rsquo;s a web application) is getting any kind of traffic at all you&amp;rsquo;ll end up creating tons of database connections, you&amp;rsquo;ll also be reading that config file every time (ok I forget if Config::Merge caches to memory, it might, but often when I see people design this way, they are basically slurping the file every time). Someday 5 years from now, someone is going to hate you because now they need to support replicants&amp;hellip; and the config needs to support more connection strings, which means modifying every place you&amp;rsquo;ve done this. Also, you&amp;rsquo;ve completely lost the ability to inject your dependencies for whatever reason you may want to. &lt;/p&gt;&lt;p&gt;&lt;h2&gt;Inheritance/Composition&lt;/h2&gt;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/xenoterracide/7048475.js&#34;&gt;&lt;/script&gt;Ok, this is a little bit better than before, at least now you have Inverted your dependencies, you could provide the config or the database handle to the class. You&amp;rsquo;ve also put the code in a centralized place so it&amp;rsquo;s easy to change when you need to. You&amp;rsquo;re still reading the file fairly often, though perhaps less because it now depends on how long Product variant is alive. So what happens if your connection is lost? We still have a connection for each class, a connection that may now be held much longer. Why does Product Variant need access to the config? this is a violation of the Law of Demeter. &lt;/p&gt;&lt;h2&gt;Naive Service Locator&lt;/h2&gt;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/xenoterracide/7048828.js&#34;&gt;&lt;/script&gt;We need to get rid of knowledge of the config. We can do this by using a &lt;a href=&#34;http://martinfowler.com/articles/injection.html#UsingAServiceLocator&#34;&gt;Service Locator&lt;/a&gt;, which is simply a well known service to retrieve other services, usually a global singleton. In our example we&amp;rsquo;re at least smart enough to allow ourselves to change the class out via injection for testing. We no longer have tons of connections or config reads. However, we now have a new problems, what happens when our Application Server forks a process and we lose the database connection? What about when our locator gets more complex, like nested containers, that could change or access, specifically with replication. Also our class is now directly dependent on Bread::Board, and its interface. At least we&amp;rsquo;ve stopped caring how our database handle is built. Our locator is a global singleton, and we can&amp;rsquo;t change our Container class for testing. &lt;/p&gt;&lt;h2&gt;Robust Service Locator&lt;/h2&gt;&lt;p&gt;&lt;script src=&#34;https://gist.github.com/xenoterracide/7049630.js&#34;&gt;&lt;/script&gt;Ok, so this is much better we can now configure which locator instance we use at runtime. We have removed the dependency on the Bread::board interface. There is no longer a problem with database connections being dropped. However, our container is still a global singleton, and our class still knows about it, which again, law of Demeter. &lt;/p&gt;&lt;h2&gt;Dependency Injection and Pass it down&lt;/h2&gt;&lt;p&gt;For now I&amp;rsquo;ve been basically ignoring other classes because with all of these other approaches they aren&amp;rsquo;t really a concern because you would do the same thing in every class, fetch your service. Much of the code is required here anyways, we always would have to do the sql, the transforms the loops. Dependency inversion is the opposite, do not think of how to retrieve the dependency instead have the dependency provided. But this becomes tricky to think of when you&amp;rsquo;re 3 or more levels deep in your hierarchy. One way to do it simply pass the reference. We create a specific problem here, our Repository lifecycle is a singleton so we need to ensure re-connection, thus we must inject the connector which means we are immediately dependent on the DBIx::Connector interface. This doesn&amp;rsquo;t seem that tricky until you add more than one service, which still may not seem that bad, until you have to add one later, and oh my god, now you&amp;rsquo;re modifying several classes. &lt;script src=&#34;https://gist.github.com/xenoterracide/7051143.js&#34;&gt;&lt;/script&gt;&lt;h2&gt;Dependency Injection with Providers&lt;/h2&gt;&lt;p&gt;This next and final sample show&amp;rsquo;s one way of doing this with Providers. A little context on a Provider first, a Provider is simply an object that can be used to retrieve a an instance of an object you need. It&amp;rsquo;s really just a kind of factory, but tends to be specific to dependency injection, in scenarios where you need a new instance of an object each time. It seems that it might also work well for other cases, such as objects with a longer lifespan than a new instance on every request from the injector, but shorter than a permanent singleton. In short a provider should be able to provide you with an instance on request, without requiring to to depend on retrieval. &lt;/p&gt;&lt;p&gt;The code that I&amp;rsquo;m demonstrating will not work currently practical scenario, meaning one where variant parameters are required. &lt;a href=&#34;https://github.com/stevan/BreadBoard/issues/28&#34;&gt;I&amp;rsquo;ve opened a bug about resolving the issue&lt;/a&gt;. In the mean time, the patch is simple and you could apply it yourself. You could use &lt;code&gt;BUILDARGS&lt;/code&gt; to rename an alternate key to the primary hashkey, in your models. You could also just define each model service one at a time instead of looping them, and actually validating their parameters. &lt;/p&gt;&lt;script src=&#34;https://gist.github.com/xenoterracide/7052294.js&#34;&gt;&lt;/script&gt;&lt;p&gt;You may note that I&amp;rsquo;ve removed the config, this was simply so I could build the code out so it works in completion. It maybe advantageous not to put config processing code in the Dependency injector, but rather provide the config to Bread::Board::Declare at the constructor via required services. This way of doing things requires much more code, but is also much more flexible. Every piece of the model, even those hat could not normally be accessed by the injector, can now have it&amp;rsquo;s dependencies injected to it. &lt;/p&gt;&lt;div class=&#34;blogger-post-footer&#34;&gt;&lt;br /&gt;&amp;ndash;&lt;br /&gt;
This &lt;span xmlns:dc=&#34;http://purl.org/dc/elements/1.1/&#34; href=&#34;http://purl.org/dc/dcmitype/Text&#34; rel=&#34;dc:type&#34;&gt;work&lt;/span&gt; by &lt;a xmlns:cc=&#34;http://creativecommons.org/ns#&#34; href=&#34;http://www.xenoterracide.com&#34; property=&#34;cc:attributionName&#34; rel=&#34;cc:attributionURL&#34;&gt;Caleb Cushing&lt;/a&gt; is licensed under a &lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/3.0/&#34;&gt;Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inversion of Control Principle</title>
      <link>http://blog.xenoterracide.com/post/inversion-of-control-principle/</link>
      <pubDate>Thu, 03 Jan 2013 21:00:00 +0000</pubDate>
      
      <guid>http://blog.xenoterracide.com/post/inversion-of-control-principle/</guid>
      <description>&lt;p&gt;&lt;p&gt;If you&amp;rsquo;re not familiar with the term &amp;ldquo;Inversion of Control&amp;rdquo;( IoC ) or &amp;ldquo;Dependency Injection&amp;rdquo; ( DI )you may wish to start with &lt;a href=&#34;http://martinfowler.com/articles/injection.html&#34;&gt;Martin Fowler&amp;rsquo;s post on the subject&lt;/a&gt;. If you&amp;rsquo;re looking for a way to do it with Perl,  &lt;a href=&#34;https://metacpan.org/module/Bread::Board::Manual::Concepts&#34;&gt;Bread::Board&lt;/a&gt; is the way to go. This post however is about the theory behind it, and a path to grokitude if you&amp;rsquo;re finding the concepts challenging. I should advise that I am not yet a buddha on implementation. &lt;/p&gt;&lt;h2&gt;What is it?&lt;/h2&gt;&lt;p&gt;Now that you&amp;rsquo;re familiar with an understanding of the terms that is not mine (or even if you didn&amp;rsquo;t bother), you may be wondering what I mean by &amp;ldquo;Inversion of Control Principle&amp;rdquo;, seeing as how we have the Dependency Injection Pattern and Inversion of Control Containers. I&amp;rsquo;m not sure if anyone actually uses the term &amp;ldquo;Inversion of Control Principle&amp;rdquo;, though google seems to suggest I am not the first. &lt;/p&gt;&lt;p&gt;The essence of the Inversion of Control Principle is do not attempt to control your code, let its callers control it. Give your caller as much power as you can. &lt;/p&gt;&lt;p&gt;This is of course not a very academic statement&lt;/p&gt;&lt;h3&gt;Dependency Inversion&lt;/h3&gt;&lt;p&gt;An important piece of the Inversion of Control Principle is the common &amp;ldquo;Dependency  Inversion&amp;rdquo;. It is defined as: &lt;blockquote&gt;&lt;ol&gt;  &lt;li&gt;High-level modules should not depend on low-level modules. Both should depend on abstractions.&lt;/li&gt;  &lt;li&gt;Abstractions should not depend upon details. Details should depend upon abstractions.&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;In more laymans terms depend on an interface and not a concrete implementation. For the Perler&amp;rsquo;s. Do not depend on LWP or DBI, but depend on their interface. This is covered more in my post on &lt;a href=&#34;http://www.xenoterracide.com/2012/11/interface-driven-design.html&#34;&gt;Interface Driven Design&lt;/a&gt;. &lt;/p&gt;&lt;h3&gt;Lifecycle Inversion of Control&lt;/h3&gt;&lt;p&gt;A second piece of Inversion of Control is do not attempt to control your objects lifecycle. This means, do not enforce a singleton pattern, do not enforce a flyweight pattern, do not enforce an instance. Your objects should be instances always, if you want a singleton put it at the top level of your application or use a Dependency Injection framework to manage the lifecycle. Also package variables that are not constants are evil, they will bite you because they are essentially singletons. Always make your objects instances and let their client code determine their lifecycle. &lt;/p&gt;&lt;h2&gt;How do I do it?&lt;/h2&gt;&lt;p&gt;Well you don&amp;rsquo;t have to use a fancy IoC/DI framework to do it. Those are simple tools to make life easier after you&amp;rsquo;ve designed your software to be consumed by them. To properly invert your control you first start by letting go. Huh? yeah I know.&lt;/p&gt;&lt;p&gt;You start by ensuring that your software has as few concrete dependencies as possible. Like I said you depend on interfaces. Some concrete dependencies are unavoidable, but try to make them uninteresting, or architecturally significant.&lt;/p&gt;&lt;h3&gt;With Perl&lt;/h3&gt;&lt;p&gt;Start by ensuring that concrete dependencies can be easily replaced at runtime. The easiest way to accomplish this is by allowing them to be passed to your constructor. when using Moose I tend to use lazy loading defaults a lot. Here&amp;rsquo;s an example from cybersource. &lt;script src=&#34;https://gist.github.com/4008988.js&#34;&gt; &lt;/script&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;sub _build_cybs_wsdl {&lt;br /&gt;    my $self = shift;&lt;br /&gt; &lt;br /&gt;    my $dir = $self-&amp;gt;_production ? &amp;lsquo;production&amp;rsquo; : &amp;lsquo;test&amp;rsquo;;&lt;br /&gt; &lt;br /&gt;    load &amp;lsquo;File::ShareDir::ProjectDistDir&amp;rsquo;, &amp;lsquo;dist_file&amp;rsquo;;&lt;br /&gt;    return load_class(&amp;lsquo;Path::Class::File&amp;rsquo;)-&amp;gt;new(&lt;br /&gt;            dist&lt;em&gt;file(&lt;br /&gt;                &amp;lsquo;Business-CyberSource&amp;rsquo;,&lt;br /&gt;                $dir&lt;br /&gt;                . &amp;lsquo;/&amp;rsquo;&lt;br /&gt;                . &amp;lsquo;CyberSourceTransaction&lt;/em&gt;&amp;lsquo;&lt;br /&gt;                . $self-&amp;gt;cybs_api_version&lt;br /&gt;                . &amp;lsquo;.wsdl&amp;rsquo;&lt;br /&gt;            )&lt;br /&gt;        );&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;has cybs_wsdl =&amp;gt; (&lt;br /&gt;    required  =&amp;gt; 0,&lt;br /&gt;    lazy      =&amp;gt; 1,&lt;br /&gt;    is        =&amp;gt; &amp;lsquo;ro&amp;rsquo;,&lt;br /&gt;    isa       =&amp;gt; File,&lt;br /&gt;    builder   =&amp;gt; &amp;lsquo;_build_cybs_wsdl&amp;rsquo;,&lt;br /&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;Although I don&amp;rsquo;t consider it likely that anyone will ever need to use another WSDL for Cybersource, one could easily inject a new Path::Class::File to one when creating the client at the constructor. Another perfect example is the Client itself. It&amp;rsquo;s designed to be useable as a singleton, because I never intend for someone to need to instantiate it twice, however I have not made it a singleton and internally I&amp;rsquo;m not aware of any code that it actually is treated as such (it appears to usually be instantiated at every request ). &lt;/p&gt;&lt;p&gt;Prefer Class, and Object interfaces to functional ones. Here&amp;rsquo;s some code that demonstrates why. &lt;script src=&#34;https://gist.github.com/4009088.js&#34;&gt; &lt;/script&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;# this works&lt;br /&gt;&lt;br /&gt;use Class::Load 0.20 &amp;lsquo;load_class&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;my $var = &amp;lsquo;baz&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;my $class = &amp;lsquo;Foo::Bar&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;my $result = load_class( $class )-&amp;gt;class_method( $var ); # works wonders with -&amp;gt;new&lt;br /&gt;&lt;br /&gt;# sometimes this will work, but not always. Try this with the various Dumper functions and see which ones work.&lt;br /&gt;&lt;br /&gt;use Module::Load &amp;lsquo;load&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;my $package = &amp;lsquo;Foo::Bar&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;load $package, &amp;lsquo;function&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;my $result = function( $var ); # seems to only work if Foo::Bar&amp;rsquo;s exporter works right, many packages have to be exported at compile time not runtime&lt;br /&gt;&lt;br /&gt;# perl doesn&amp;rsquo;t like stuff like this or really anything where I&amp;rsquo;ve tried substituting the package name into calling a function. at least not with strict on. This is a large reason I&amp;rsquo;d avoid functional interfaces. They are hard to substitute at runtime. &lt;br /&gt;&lt;br /&gt;load( $package );&lt;br /&gt;&lt;br /&gt;my $function = $package . &amp;lsquo;::&amp;rsquo; . &amp;lsquo;function&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;$function-&amp;gt;( $var );&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;/p&gt;&lt;p&gt;I have even better real examples, such as my one in interfaces where I replaced LWP with the AnyEvent::LWP&amp;hellip; but unfortunately that code has not been released to the public. The examples given are basically the same principle. &lt;/p&gt;&lt;h2&gt;Dependency Injection Frameworks&lt;/h2&gt;&lt;p&gt;Dependency Injection Frameworks are not required to use the Inversion of Control Principle they simply make injecting your dependencies and managing lifecycles easier. It also allows you to do concrete class substitution from one place along with deciding that objects lifecyle, and have it&amp;rsquo;s dependencies inserted. When using a DI framework you should strive to call it only once per controller. Though a book that I&amp;rsquo;ve read suggests this is Domain Model controller and not an MVC controller, I was unable to make a full distinction.&lt;/p&gt; &lt;p&gt;This example runs particularly slow, probably due to reasons that people hate moose, however, if you remove the loop at the end you&amp;rsquo;ll notice executing one time is about the same as ten, which means that most of this is due to class compiling and loading, actual runtime is fast (or at least, fast enough). &lt;/p&gt; &lt;p&gt;The important thing to pick up is how the Order object requires a &lt;code&gt;payment_gateway&lt;/code&gt; that does &lt;code&gt;submit&lt;/code&gt;, but it doesn&amp;rsquo;t know how to get that object, or what the implementation will be. Our Dependency Injection framework then simply provides that dependency as needed. It would be trivial to replace our implementation of payment gateway with a different one. &lt;/p&gt; &lt;p&gt;The code is commented, to explain what it&amp;rsquo;s doing where.&lt;/p&gt;&lt;script src=&#34;https://gist.github.com/4053667.js&#34;&gt; &lt;/script&gt;&lt;noscript&gt;&lt;pre&gt;&lt;code&gt;&lt;br /&gt;use 5.014;&lt;br /&gt;use warnings;&lt;br /&gt;use Class::Load &amp;lsquo;load_class&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;package PaymentGateway {&lt;br /&gt;    use Moose;&lt;br /&gt;&lt;br /&gt;    sub submit {&lt;br /&gt;        return int( rand(2) );&lt;br /&gt;    }&lt;br /&gt;    &lt;strong&gt;PACKAGE&lt;/strong&gt;-&amp;gt;meta-&amp;gt;make_immutable;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;package Order {&lt;br /&gt;    use Moose;&lt;br /&gt;&lt;br /&gt;    sub make_payment {&lt;br /&gt;        my $self = shift;&lt;br /&gt;&lt;br /&gt;        return $self-&amp;gt;_payment_gateway-&amp;gt;submit( $self );&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    has _payment_gateway =&amp;gt; (&lt;br /&gt;        isa      =&amp;gt; &amp;lsquo;Object&amp;rsquo;,&lt;br /&gt;        is       =&amp;gt; &amp;lsquo;ro&amp;rsquo;,&lt;br /&gt;        required =&amp;gt; 1,&lt;br /&gt;    );&lt;br /&gt;&lt;br /&gt;    &lt;strong&gt;PACKAGE&lt;/strong&gt;-&amp;gt;meta-&amp;gt;make_immutable;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;package AppContainer {&lt;br /&gt;    use Moose;&lt;br /&gt;    extends &amp;lsquo;Bread::Board::Container&amp;rsquo;;&lt;br /&gt;&lt;br /&gt;    use Bread::Board; #import sugar&lt;br /&gt;&lt;br /&gt;    sub _build_config {&lt;br /&gt;        my $self = shift;&lt;br /&gt;&lt;br /&gt;        # hardcode for example&lt;br /&gt;        return {&lt;br /&gt;            username   =&amp;gt; &amp;lsquo;foo&amp;rsquo;,&lt;br /&gt;            password   =&amp;gt; &amp;lsquo;bar&amp;rsquo;,&lt;br /&gt;        };&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    has _config =&amp;gt; (&lt;br /&gt;        isa     =&amp;gt; &amp;lsquo;HashRef&amp;rsquo;,&lt;br /&gt;        is      =&amp;gt; &amp;lsquo;ro&amp;rsquo;,&lt;br /&gt;        lazy    =&amp;gt; 1,&lt;br /&gt;        builder =&amp;gt; &amp;lsquo;_build_config&amp;rsquo;,&lt;br /&gt;    );&lt;br /&gt;&lt;br /&gt;    sub BUILD {&lt;br /&gt;        my $self = shift;&lt;br /&gt;&lt;br /&gt;        # container can take a container as a parameter. if you do this it&lt;br /&gt;        # will simply add to the container it tooks as a paramter&lt;br /&gt;        # this will be our root container /&lt;br /&gt;        container $self =&amp;gt; as {&lt;br /&gt;            # subcontainer path to will be /model&lt;br /&gt;            container model =&amp;gt; as {&lt;br /&gt;&lt;br /&gt;                #  order uses constructor injection&lt;br /&gt;                service order =&amp;gt; (&lt;br /&gt;                    class =&amp;gt; &amp;lsquo;Order&amp;rsquo;,&lt;br /&gt;                    dependencies =&amp;gt; {&lt;br /&gt;                        # use full path&lt;br /&gt;                        _payment_gateway =&amp;gt;&lt;br /&gt;                            depends_on(&amp;lsquo;/remote/payment_gateway&amp;rsquo;),&lt;br /&gt;                    },&lt;br /&gt;                );&lt;br /&gt;            };&lt;br /&gt;            # another subcontainer /service&lt;br /&gt;            container remote =&amp;gt; as {&lt;br /&gt;                service username   =&amp;gt; $self-&amp;gt;_config-&amp;gt;{username};&lt;br /&gt;                service password   =&amp;gt; $self-&amp;gt;_config-&amp;gt;{password};&lt;br /&gt;&lt;br /&gt;                service payment_gateway =&amp;gt; (&lt;br /&gt;                    class        =&amp;gt; &amp;lsquo;PaymentGateway&amp;rsquo;,&lt;br /&gt;                    # we don&amp;rsquo;t need more than one instance&lt;br /&gt;                    lifecycle    =&amp;gt; &amp;lsquo;Singleton&amp;rsquo;,&lt;br /&gt;                    dependencies =&amp;gt; {&lt;br /&gt;                        username   =&amp;gt; depends_on(&amp;lsquo;username&amp;rsquo;),&lt;br /&gt;                        password   =&amp;gt; depends_on(&amp;lsquo;password&amp;rsquo;),&lt;br /&gt;                    },&lt;br /&gt;                );&lt;br /&gt;            };&lt;br /&gt;        };&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    &lt;strong&gt;PACKAGE&lt;/strong&gt;-&amp;gt;meta-&amp;gt;make_immutable;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;package Controller {&lt;br /&gt;    # this could be any framework controller&lt;br /&gt;    use Moose;&lt;br /&gt;&lt;br /&gt;    has _c =&amp;gt; (&lt;br /&gt;        isa  =&amp;gt; &amp;lsquo;Bread::Board::Container&amp;rsquo;,&lt;br /&gt;        is   =&amp;gt; &amp;lsquo;ro&amp;rsquo;,&lt;br /&gt;    );&lt;br /&gt;&lt;br /&gt;    sub process_order {&lt;br /&gt;        my $self = shift;&lt;br /&gt;&lt;br /&gt;        my $order = $self-&amp;gt;_c-&amp;gt;resolve( service =&amp;gt; &amp;lsquo;/model/order&amp;rsquo; );&lt;br /&gt;&lt;br /&gt;        if ( $order-&amp;gt;make_payment ) {&lt;br /&gt;            say &amp;lsquo;payment succeeded&amp;rsquo;;&lt;br /&gt;        }&lt;br /&gt;        else {&lt;br /&gt;            say &amp;lsquo;payment failed&amp;rsquo;;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;    &lt;strong&gt;PACKAGE&lt;/strong&gt;-&amp;gt;meta-&amp;gt;make_immutable;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;my $app = AppContainer-&amp;gt;new({ name =&amp;gt; &amp;lsquo;app&amp;rsquo; });&lt;br /&gt;&lt;br /&gt;# controller has not idea there&amp;rsquo;s only one app containerr&lt;br /&gt;my $controller = Controller-&amp;gt;new( _c =&amp;gt; $app );&lt;br /&gt;&lt;br /&gt;for ( my $i = 0; $i &amp;lt; 10 ; $i++ ) {&lt;br /&gt;    $controller-&amp;gt;process_order;&lt;br /&gt;}&lt;br /&gt;1;&lt;br /&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/noscript&gt;&lt;/p&gt;&lt;div class=&#34;blogger-post-footer&#34;&gt;&lt;br /&gt;&amp;ndash;&lt;br /&gt;
This &lt;span xmlns:dc=&#34;http://purl.org/dc/elements/1.1/&#34; href=&#34;http://purl.org/dc/dcmitype/Text&#34; rel=&#34;dc:type&#34;&gt;work&lt;/span&gt; by &lt;a xmlns:cc=&#34;http://creativecommons.org/ns#&#34; href=&#34;http://www.xenoterracide.com&#34; property=&#34;cc:attributionName&#34; rel=&#34;cc:attributionURL&#34;&gt;Caleb Cushing&lt;/a&gt; is licensed under a &lt;a rel=&#34;license&#34; href=&#34;http://creativecommons.org/licenses/by-nc-sa/3.0/&#34;&gt;Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>